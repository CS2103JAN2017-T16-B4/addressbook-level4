# A0139448U
###### \src\main\java\org\teamstbf\yats\logic\commands\ChangeSaveLocationCommand.java
``` java
/*
 * Command to change file directory location
 * where task manager XML file is saved to
 */
public class ChangeSaveLocationCommand extends Command {

	public final static String COMMAND_WORD = "save";
	public final static String MESSAGE_WRONG_INPUT = "Illegal input.";
	public final static String MESSAGE_DUPLICATE_FILE_PATH = "Given file directory is already data save location.";
	public final static String MESSAGE_CHANGE_SUCCESS = "Save location changed to: ";
	public static final String MESSAGE_USAGE = COMMAND_WORD
			+ ": Changes the file directory on disk that task manager data is saved to "
			+ "Existing save location will be overwritten by the new save location file directory.\n"
			+ "Parameters: New File Directory" + "Example: " + COMMAND_WORD + " /Users/dionngg/Desktop/others";

	private static final Logger logger = LogsCenter.getLogger(ChangeSaveLocationCommand.class);

	private File saveLocation;

	public ChangeSaveLocationCommand(File location) {
		this.saveLocation = location;
	}

	@Override
	public CommandResult execute() throws CommandException {
		Config newConfig;
		try {
			Optional<Config> configOptional = ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE);
			newConfig = configOptional.orElse(new Config());
			newConfig.setTaskManagerFilePath(saveLocation.toString());
			ConfigUtil.saveConfig(newConfig, Config.DEFAULT_CONFIG_FILE);
			XmlTaskManagerStorage.setTaskManagerFilePath(saveLocation.toString());
			model.saveTaskManager();
		} catch (Config.DuplicateFileException dupExcep) {
			throw new CommandException(MESSAGE_DUPLICATE_FILE_PATH);
		} catch (IOException ioe) {
			throw new CommandException(MESSAGE_WRONG_INPUT);
		} catch (DataConversionException e) {
			logger.warning("Config file at " + Config.DEFAULT_CONFIG_FILE + " is not in the correct format. "
					+ "Using default config properties");
		}
		return new CommandResult(MESSAGE_CHANGE_SUCCESS + saveLocation.toString());
	}

}
```
###### \src\main\java\org\teamstbf\yats\logic\commands\ClearDoneCommand.java
``` java
/**
 * Command to Clear the done tasks in the task manager.
 */
public class ClearDoneCommand extends Command {

	public static final String COMMAND_WORD = "clear";
	public static final String MESSAGE_SUCCESS = "All done tasks have been cleared!";
	public static final String MESSAGE_ALREADY_CLEAR = "There are no done tasks to clear!";
	private static final String TASK_DONE_IDENTIFIER = "Yes";

	@Override
	public CommandResult execute() {
		Set<String> doneTaskIdentifier = new HashSet<String>();
		doneTaskIdentifier.add(TASK_DONE_IDENTIFIER);
		model.updateFilteredListToShowDone(doneTaskIdentifier);

		UnmodifiableObservableList<ReadOnlyEvent> lastShownList = model.getFilteredTaskList();

		int formerSize = lastShownList.size();
		model.saveImageOfCurrentTaskManager(); // For undo command

		for (int index = 0; index < lastShownList.size(); index++) {
			if (lastShownList.get(index).getIsDone().getValue().equals(IsDone.ISDONE_DONE)) {
				ReadOnlyEvent eventToDelete = lastShownList.get(index);
				try {
					model.deleteEvent(eventToDelete);
				} catch (EventNotFoundException pnfe) {
					assert false : "The target task cannot be missing";
				}
				index--;
			}
		}
		if (formerSize == lastShownList.size()) { // Check if any deletes occurred
			model.updateFilteredListToShowAll();
			return new CommandResult(MESSAGE_ALREADY_CLEAR);
		}
		model.updateFilteredListToShowAll();
		return new CommandResult(MESSAGE_SUCCESS);
	}

}
```
###### \src\main\java\org\teamstbf\yats\logic\commands\MarkDoneCommand.java
``` java
/**
 *
 * Command to Mark an existing task as done in the task scheduler.
 */
public class MarkDoneCommand extends Command {

	public static final String COMMAND_WORD = "mark";
	public static final String MESSAGE_EDIT_TASK_SUCCESS = "Task marked as done: %1$s";
	public static final String MESSAGE_ALR_MARKED = "Task already marked as done.";

	public static final String MESSAGE_USAGE = COMMAND_WORD + ": Marks the task identified as done "
			+ "by the index number used in the last task listing. "
			+ "Parameters: INDEX (must be a positive integer) "
			+ "Example: " + COMMAND_WORD + " 1";

	public final int targetIndex;

	public MarkDoneCommand(int targetIndex) {
		assert targetIndex > 0;
		this.targetIndex = targetIndex - 1;
	}

	@Override
	public CommandResult execute() throws CommandException {

		List<ReadOnlyEvent> lastShownList = model.getFilteredTaskList();

		if (targetIndex >= lastShownList.size()) {
			throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
		}

		ReadOnlyEvent taskToMark = lastShownList.get(targetIndex);
		Event markedTask = new Event(taskToMark.getTitle(), taskToMark.getLocation(), taskToMark.getStartTime(), taskToMark.getEndTime(), taskToMark.getDeadline(), taskToMark.getDescription(), taskToMark.getTags(), new IsDone(), taskToMark.isRecurring(), taskToMark.getRecurrence());

		if (markedTask.getIsDone().getValue().equals(IsDone.ISDONE_DONE)) {
			return new CommandResult(MESSAGE_ALR_MARKED);
		}

		model.saveImageOfCurrentTaskManager(); // For undo command

		if (markedTask.isRecurring()) {
			markedTask.markDone();
		} else {
			markedTask.getIsDone().markDone();
		}

		model.updateEvent(targetIndex, markedTask);
		model.updateDoneTaskList();
		model.updateFilteredListToShowAll();
		markedTask.setPriority(0);
		return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToMark));
	}

}
```
###### \src\main\java\org\teamstbf\yats\logic\commands\MarkUndoneCommand.java
``` java
/**
 *
 * Command to Mark an existing task as not done in the task scheduler.
 */
public class MarkUndoneCommand extends Command {

	public static final String COMMAND_WORD = "unmark";
	public static final String MESSAGE_EDIT_TASK_SUCCESS = "Task marked as not done: %1$s";
	public static final String MESSAGE_ALR_MARKED = "Task is already marked as not done.";
	public static final String MESSAGE_NO_DONE_OCCURENCE = "Recurring task has no done occurrence.";

	public static final String MESSAGE_USAGE = COMMAND_WORD + ": Marks the task identified as not done "
			+ "by the index number used in the last task listing. " + "Parameters: INDEX (must be a positive integer) "
			+ "Example: " + COMMAND_WORD + " 1";

	private static final String TASK_DONE_IDENTIFIER = "Yes";

	public final int targetIndex;

	public MarkUndoneCommand(int targetIndex) {
		assert targetIndex > 0;
		this.targetIndex = targetIndex - 1;
	}

	@Override
	public CommandResult execute() throws CommandException {
		List<ReadOnlyEvent> lastShownList = retrieveDoneTaskList();

		if (targetIndex >= lastShownList.size()) {
			throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
		}

		ReadOnlyEvent taskToMark = lastShownList.get(targetIndex);
		Event markedTask = new Event(taskToMark.getTitle(), taskToMark.getLocation(), taskToMark.getStartTime(), taskToMark.getEndTime(), taskToMark.getDeadline(), taskToMark.getDescription(), taskToMark.getTags(), new IsDone("Yes"), taskToMark.isRecurring(), taskToMark.getRecurrence());

		model.saveImageOfCurrentTaskManager(); // For undo command

		if (markedTask.isRecurring()) {
			if (markedTask.getRecurrence().hasDoneOccurence()) {
				markedTask.getRecurrence().markOccurenceUndone();
			} else {
				return new CommandResult(MESSAGE_ALR_MARKED);
			}
		} else {
			if (markedTask.getIsDone().getValue().equals(IsDone.ISDONE_NOTDONE)) {
				return new CommandResult(MESSAGE_ALR_MARKED);
			}
			markedTask.getIsDone().markUndone();
		}

		model.updateEvent(targetIndex, markedTask);
		model.updateDoneTaskList();
		model.updateFilteredListToShowAll();
		markedTask.setPriority(1);
		return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToMark));
	}

	/*
	 * Returns a filtered task list of done tasks to be
	 * displayed in done task list on right of UI
	 */
	private List<ReadOnlyEvent> retrieveDoneTaskList() {
		Set<String> doneTaskIdentifier = new HashSet<String>();
		doneTaskIdentifier.add(TASK_DONE_IDENTIFIER);
		model.updateFilteredListToShowDone(doneTaskIdentifier);
		return model.getFilteredTaskList();
	}

}
```
###### \src\main\java\org\teamstbf\yats\logic\parser\ChangeSaveLocationCommandParser.java
``` java
public class ChangeSaveLocationCommandParser {

	public final static String INPUT_DEFAULT = "default";
	public final static String INVALID_SAVE_LOCATION = "Invalid save location.";
	public final static String NO_LOCATION_SPECIFIED = "Please specify a save location";

	/**
	 * Parses the given {@code String} of arguments in the context of the
	 * ChangeSaveLocationCommand and returns an ChangeSaveLocationCommand object
	 * for execution.
	 */
	public Command parse(String arguments) {
		assert arguments != null;

		arguments = arguments.trim();

		if (arguments.equals("")) {
			return new IncorrectCommand(NO_LOCATION_SPECIFIED);
		}

		if (arguments.equals(INPUT_DEFAULT)) { // Convenient for users to change to default save location
			return new ChangeSaveLocationCommand(new File("data/YATS.xml"));
		}

		File saveLocation = new File(arguments.trim());

		if (!saveLocation.exists()) {
			return new IncorrectCommand(INVALID_SAVE_LOCATION);
		} else {
			if (!arguments.endsWith("/")) {
				arguments += "/";
			}
			File newSaveLocation = new File(arguments + "YATS.xml");
			return new ChangeSaveLocationCommand(newSaveLocation);
		}

	}

}
```
###### \src\main\java\org\teamstbf\yats\logic\parser\MarkDoneCommandParser.java
``` java
/**
 * Parses input arguments and creates a new MarkDoneCommand object
 */
public class MarkDoneCommandParser {

	private Stack<Integer> markStack = new Stack<Integer>();

	/**
	 * Parses the given {@code String} of arguments in the context of the
	 * MarkDoneCommand and returns an MarkDoneCommand object for execution.
	 */
	public Command parse(String args) {

		String[] markIndexArr = ParserUtil.stringTokenizer(args);
		if (markIndexArr.length > 1) {
			if (ParserUtil.isAllIntegers(markIndexArr)) {
				return convertToBatchMarkCommand(markIndexArr);
			} else if (!ParserUtil.isAllIntegers(markIndexArr)) {
				return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, BatchDeleteCommand.MESSAGE_USAGE));
			}
		}

		Optional<Integer> index = ParserUtil.parseIndex(args);
		if (!index.isPresent()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkDoneCommand.MESSAGE_USAGE));
		}

		return new MarkDoneCommand(index.get());
	}

	public Command convertToBatchMarkCommand(String[] markIndexArr) {
		markIndexArr = ParserUtil.sortIndexArr(markIndexArr);
		for (String element : markIndexArr) {
			if (!markStack.contains(Integer.valueOf(element) - 1)) {
				markStack.push(Integer.valueOf(element) - 1);
			}
		}
		return new BatchMarkDoneCommand(markStack);
	}

}
```
###### \src\main\java\org\teamstbf\yats\logic\parser\MarkUndoneCommandParser.java
``` java
/**
 * Parses input arguments and creates a new MarkUndoneCommand object
 */
public class MarkUndoneCommandParser {

	private Stack<Integer> markStack = new Stack<Integer>();

	/**
	 * Parses the given {@code String} of arguments in the context of the
	 * MarkDoneCommand and returns an MarkDoneCommand object for execution.
	 */
	public Command parse(String args) {

		String[] markIndexArr = ParserUtil.stringTokenizer(args);
		if (markIndexArr.length > 1) {
			if (ParserUtil.isAllIntegers(markIndexArr)) {
				return convertToBatchUnmarkDoneCommand(markIndexArr);
			} else if (!ParserUtil.isAllIntegers(markIndexArr)) {
				return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, BatchDeleteCommand.MESSAGE_USAGE));
			}
		}

		Optional<Integer> index = ParserUtil.parseIndex(args);
		if (!index.isPresent()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkDoneCommand.MESSAGE_USAGE));
		}

		return new MarkUndoneCommand(index.get());
	}

	public Command convertToBatchUnmarkDoneCommand(String[] markIndexArr) {
		markIndexArr = ParserUtil.sortIndexArr(markIndexArr);
		for (String element : markIndexArr) {
			if (!markStack.contains(Integer.valueOf(element) - 1)) {
				markStack.push(Integer.valueOf(element) - 1);
			}
		}
		return new BatchUnmarkDoneCommand(markStack);
	}

}
```
###### \src\main\java\org\teamstbf\yats\model\item\IsDone.java
``` java
/**
 * Represents a Task's completeness in the Task Manager.
 */
public class IsDone {

	public static final String MESSAGE_ISDONE_CONSTRAINTS = "IsDone must be Yes or No";
	public static final String ISDONE_VALIDATION_REGEX = ".*(Yes|No).*";

	public final static String ISDONE_NOTDONE = "No";
	public final static String ISDONE_DONE = "Yes";

	private String value;

	public IsDone() {
		this.value = ISDONE_NOTDONE;
	}

	public IsDone(String done) {
		String trimmedIsDone = done.trim();
		this.value = trimmedIsDone;
	}

	public static boolean isValidIsDone(String test) {
		return test.matches(ISDONE_VALIDATION_REGEX);
	}

	public String getValue() {
		return value;
	}

	public void markDone() {
		this.value = ISDONE_DONE;
	}

	public void markUndone() {
		this.value = ISDONE_NOTDONE;
	}

}
```
###### \src\main\java\org\teamstbf\yats\model\item\Schedule.java
``` java
	/*
	 * Checks to make sure time matches 12 hour clock format with capital AM/PM
	 * Checks date given exist according to calendar including leap years
	 */
	public static boolean isValidSchedule(String timeDate) {
		String[] date = timeDate.split("\\s+");
		/*if (date.length != 2 ) {
			return false;
		}*/
		return (date[0].trim().matches(TIME_VALIDATION_REGEX) && validateDate(date[1]));
	}

	/*
	 * Checks date given exist according to calendar including leap years
	 */
	public static boolean validateDate(String date) {

		String[] splitDate = date.split("/");
		if (splitDate.length != 3 || splitDate[0].trim().length() != 2 || splitDate[1].trim().length() != 2 || splitDate[2].trim().length() != 4) {
			return false;
		}

		int day = Integer.parseInt(splitDate[0]);
		String month = splitDate[1];
		int year = Integer.parseInt(splitDate[2]);

		if (!month.matches(MONTH_VALIDATION_REGEX)) {
			return false;
		}

		if (day > 31) {
			return false;
		}

		if (day > 30 && (month.equals("11") || month.equals("04") || month .equals("06") || month.equals("09"))) {
			return false; // only 1, 3, 5, 7, 8, 10, 12 have 31 days
		} else if (month.equals("02")) {
			if ((year % 4 == 0 && year % 100 != 0) || (year % 4 == 0 && year % 1000 == 0)) { // leap year
				if (day > 29) {
					return false;
				} else {
					return true;
				}
			} else {
				if (day > 28) {
					return false;
				} else {
					return true;
				}
			}
		} else {
			return true;
		}

	}
}
```
###### \src\main\java\org\teamstbf\yats\model\Model.java
``` java

    /*
     * force saves the current state of the taskmanager for use in changing save
     * location to create a file in new location
     */
    void saveTaskManager();

```
###### \src\main\java\org\teamstbf\yats\model\tag\UniqueTagList.java
``` java
	public void removeAndMerge(UniqueTagList from) {
		final Set<Tag> alreadyInside = this.toSet();
		from.internalList.stream().filter(tag -> alreadyInside.contains(tag)).forEach(internalList::remove);
		from.internalList.stream().filter(tag -> !alreadyInside.contains(tag)).forEach(internalList::add);
	}

	/**
	 * Returns true if the list contains an equivalent Tag as the given
	 * argument.
	 */
	public boolean contains(Tag toCheck) {
		assert toCheck != null;
		return internalList.contains(toCheck);
	}

	/**
	 * Adds a Tag to the list.
	 *
	 * @throws DuplicateTagException
	 *             if the Tag to add is a duplicate of an existing Tag in the
	 *             list.
	 */
	public void add(Tag toAdd) throws DuplicateTagException {
		assert toAdd != null;
		if (contains(toAdd)) {
			throw new DuplicateTagException();
		}
		internalList.add(toAdd);
	}

	/**
	 * Returns true if the list is not empty.
	 */
	public boolean isTagPresent() {
		if (internalList.isEmpty()) {
			return false;
		} else {
			return true;
		}
	}

	@Override
	public Iterator<Tag> iterator() {
		return internalList.iterator();
	}

	public UnmodifiableObservableList<Tag> asObservableList() {
		return new UnmodifiableObservableList<>(internalList);
	}

	@Override
	public boolean equals(Object other) {
		return other == this // short circuit if same object
				|| (other instanceof UniqueTagList // instanceof handles nulls
						&& this.internalList.equals(((UniqueTagList) other).internalList));
	}

	public boolean equalsOrderInsensitive(UniqueTagList other) {
		return this == other || new HashSet<>(this.internalList).equals(new HashSet<>(other.internalList));
	}

	@Override
	public int hashCode() {
		return internalList.hashCode();
	}

	/**
	 * Signals that an operation would have violated the 'no duplicates'
	 * property of the list.
	 */
	public static class DuplicateTagException extends DuplicateDataException {
		protected DuplicateTagException() {
			super("Operation would result in duplicate tags");
		}
	}

}
```
###### \src\test\java\org\teamstbf\yats\model\event\IsDoneTest.java
``` java
public class IsDoneTest {

	@Test
	public void test() {
		// valid IsDone
		assertTrue(IsDone.isValidIsDone("Yes")); // done task
		assertTrue(IsDone.isValidIsDone("No")); // undone task

		// invalid IsDone
		assertFalse(IsDone.isValidIsDone("yes"));
		assertFalse(IsDone.isValidIsDone("no"));
		assertFalse(IsDone.isValidIsDone("gg.com"));
	}

}
```
###### \src\test\java\org\teamstbf\yats\model\event\RecurrenceTest.java
``` java
public class RecurrenceTest {

	@Test
	public void isValidPeriod() {
		// invalid recurrence
		assertFalse(Recurrence.isValidPeriod("dail")); // typo error
		assertFalse(Recurrence.isValidPeriod("weekl")); // typo error
		assertFalse(Recurrence.isValidPeriod("")); // contains nothing
		assertFalse(Recurrence.isValidPeriod("    ")); // spaces only
		assertFalse(Recurrence.isValidPeriod("fnwuibig")); // completely invalid
															// input

		// valid recurrence
		assertTrue(Recurrence.isValidPeriod(" daily "));
		assertTrue(Recurrence.isValidPeriod(" monthly "));
		assertTrue(Recurrence.isValidPeriod(" weekly "));
		assertTrue(Recurrence.isValidPeriod(" yearly "));
		assertTrue(Recurrence.isValidPeriod(" none "));

	}

}
```
###### \src\test\java\org\teamstbf\yats\model\event\ScheduleTest.java
``` java
public class ScheduleTest {

	@Test
	public void test() {
		// invalid schedule
		assertFalse(Schedule.isValidSchedule("")); // empty string
		assertFalse(Schedule.isValidSchedule("@#$")); // only non-alphanumeric characters
		assertFalse(Schedule.isValidSchedule("f3vbt5b5")); // invalid input
		assertFalse(Schedule.isValidSchedule("05/05/2017 12:00PM")); // date before time
		assertFalse(Schedule.isValidSchedule("13:00AM 05/05/2017")); // wrong time
		assertFalse(Schedule.isValidSchedule("12:65AM 05/05/2017")); // wrong time
		assertFalse(Schedule.isValidSchedule("13:00ZM 05/05/2017")); // wrong time
		assertFalse(Schedule.isValidSchedule("12:00AM 43/05/2017")); // wrong date
		assertFalse(Schedule.isValidSchedule("12:00AM 05/00/2017")); // wrong date
		assertFalse(Schedule.isValidSchedule("12:00AM 05/13/2017")); // wrong date
		assertFalse(Schedule.isValidSchedule("14:00AM 43/05/2017")); // wrong time and date
		assertFalse(Schedule.isValidSchedule("12:00PM 29/02/2017")); // Not leap year

		// valid schedule
		assertTrue(Schedule.isValidSchedule("12:00PM 29/02/2016")); // Leap Year
		assertTrue(Schedule.isValidSchedule("12:00PM 05/05/2017"));
		assertTrue(Schedule.isValidSchedule("12:00PM 05/05/2017"));
		assertTrue(Schedule.isValidSchedule("12:59AM 05/05/2017"));
		assertTrue(Schedule.isValidSchedule("12:59AM 05/12/2017"));
		assertTrue(Schedule.isValidSchedule("12:59AM 20/05/2017"));

	}

}
```
###### \src\test\java\org\teamstbf\yats\model\event\TitleTest.java
``` java
public class TitleTest {

	@Test
	public void isValidName() {
		// invalid name
		assertFalse(Title.isValidTitle("")); // empty string
		assertFalse(Title.isValidTitle(" ")); // spaces only
		assertFalse(Title.isValidTitle("!@#$")); // only non-alphanumeric
													// characters
		assertFalse(Title.isValidTitle("DO _____??")); // contains
														// non-alphanumeric
														// characters

		// valid name
		assertTrue(Title.isValidTitle("do work now")); // alphabets only
		assertTrue(Title.isValidTitle("DO PAGE 1 TO 14")); // alphanumeric
															// characters
		assertTrue(Title.isValidTitle("12345")); // numbers only
		assertTrue(Title.isValidTitle("Do Work NOW")); // with capital letters
		assertTrue(Title.isValidTitle("Do this homework drink coffee eat bread and do whatever you want")); // long
																											// titles
	}
}
```
