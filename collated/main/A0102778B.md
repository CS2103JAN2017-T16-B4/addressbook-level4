# A0102778B
###### \src\main\java\org\teamstbf\yats\logic\commands\RedoCommand.java
``` java

/**
 * Undoes the last option that mutated the save state of the data
 */
public class RedoCommand extends Command {

	public static final String COMMAND_WORD = "redo";

	public static final String MESSAGE_UNDO_TASK_SUCCESS = "Redo completed";
	public static final String MESSAGE_EMPTY_REDO_STACK = "Nothing to redo";

	public RedoCommand() {
		// TODO Auto-generated constructor stub
	}

	@Override
	public CommandResult execute() throws CommandException {
		assert model != null;
		if (model.checkEmptyRedoStack()) {
			throw new CommandException(MESSAGE_EMPTY_REDO_STACK);
		}
		model.getNextState();
		return new CommandResult(String.format(MESSAGE_UNDO_TASK_SUCCESS));
	}
}
```
###### \src\main\java\org\teamstbf\yats\logic\commands\UndoCommand.java
``` java

/**
 * Undoes the last option that mutated the save state of the data.
 */
public class UndoCommand extends Command {

	public static final String COMMAND_WORD = "undo";
	public static final String MESSAGE_UNDO_TASK_SUCCESS = "Undo completed";
	public static final String MESSAGE_EMPTY_UNDO_STACK = "Nothing to undo";

	public UndoCommand() {
	}

	@Override
	public CommandResult execute() throws CommandException {
		assert model != null;
		if (model.checkEmptyUndoStack()) {
			throw new CommandException(MESSAGE_EMPTY_UNDO_STACK);
		}
		model.getPreviousState();
		return new CommandResult(String.format(MESSAGE_UNDO_TASK_SUCCESS));

	}
}
```
###### \src\main\java\org\teamstbf\yats\logic\parser\ScheduleCommandParser.java
``` java

/**
 * Parses input arguments and creates a new AddCommand object
 */
public class ScheduleCommandParser {

	/**
	 * Parses the given {@code String} of arguments in the context of the
	 * AddCommand and returns an AddCommand object for execution.
	 */
	public Command parse(String args) {
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_NLP_TIME, PREFIX_NLP_LOCATION, PREFIX_NLP_TAG,
				PREFIX_NLP_DESCRIPTION, PREFIX_HOURS, PREFIX_MINUTES);
		argsTokenizer.tokenize(args);
		try {
			HashMap<String, Object> addParam = new HashMap<>();
			addParam.put("name", argsTokenizer.getPreamble().get());
			addParam.put("location", argsTokenizer.getValue(PREFIX_LOCATION).orElse(null));
			addParam.put("description", argsTokenizer.getValue(PREFIX_DESCRIPTION).orElse(null));
			addParam.put("tag", ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG)));
			addParam.put("recurrence", argsTokenizer.getValue(PREFIX_RECURRENCE).orElse(null));
			addParam.put("hours", argsTokenizer.getValue(PREFIX_HOURS).orElse(null));
			addParam.put("minutes", argsTokenizer.getValue(PREFIX_MINUTES).orElse(null));
			return new ScheduleCommand(addParam);
		} catch (NoSuchElementException nsee) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ScheduleCommand.MESSAGE_USAGE));
		} catch (IllegalValueException ive) {
			return new IncorrectCommand(ive.getMessage());
		}
	}

}
```
###### \src\main\java\org\teamstbf\yats\model\Model.java
``` java
    /**
     * Method to get the previous state (undo command) of the task manager
     */
    void getPreviousState();

    /**
     * Method to get the next state (redo command) of the task manager
     */
    void getNextState();

    /**
     * Method to check if the undo stack is empty - nothing to undo
     */
    boolean checkEmptyUndoStack();

    /**
     * Method to check if the redo stack is empty - nothing to redo
     */
    boolean checkEmptyRedoStack();

    /**
     * Method to check if the redo stack is empty - nothing to redo
     */
    void scheduleEvent(Event event);

    /**
     * Saves an image of the previous state of the TaskManager for the undo
     * command - also clears the redo stack images because once the state is
     * mutated the previous redoes state are invalid because they are no longer
     * part of the same chain. This is an internal method used by the addEvent,
     * deteleEvent, clearEvent, editEvent methods. This method also contains a
     * check - if there are currently too many task manager states, it will
     * remove half of the earlier saved states and only keep the later half.
     */

    void saveImageOfCurrentTaskManager();

    void updateFilteredListToShowSortedStart();

    void updateFilteredListToShowSortedEnd();

    void updateFilteredListToShowDeadline();

}
```
###### \src\main\java\org\teamstbf\yats\model\ModelManager.java
``` java

	private static Stack<TaskManager> undoTaskManager = new Stack<TaskManager>();
	private static Stack<TaskManager> redoTaskManager = new Stack<TaskManager>();

	private final FilteredList<ReadOnlyEvent> filteredEvents;
	private final FilteredList<ReadOnlyEvent> calendarList;
	private final FilteredList<ReadOnlyEvent> taskList;

	public ModelManager() {
		this(new TaskManager(), new UserPrefs());
	}

	/**
	 * Initializes a ModelManager with the given taskManager and userPrefs.
	 */
	public ModelManager(ReadOnlyTaskManager taskManager, UserPrefs userPrefs) {
		super();
		assert !CollectionUtil.isAnyNull(taskManager, userPrefs);

		logger.fine("Initializing with task manager: " + taskManager + " and user prefs " + userPrefs);

		this.taskManager = new TaskManager(taskManager);
		filteredEvents = new FilteredList<>(this.taskManager.getTaskList());
		calendarList = new FilteredList<ReadOnlyEvent>(this.taskManager.getTaskList());
		taskList = new FilteredList<ReadOnlyEvent>(this.taskManager.getTaskList());
		undoTaskManager = new Stack<TaskManager>();
		redoTaskManager = new Stack<TaskManager>();
	}

	@Override
	public synchronized void addEvent(Event event) {
		taskManager.addEvent(event);
		updateFilteredListToShowAll();
		indicateTaskManagerChanged();
		EventsCenter.getInstance().post(new JumpToListRequestEvent(filteredEvents.size() - 1));
	}

	@Override
	public void saveImageOfCurrentTaskManager() {
		removeUndoEntriesIfUndoStackSizeTooLarge();
		TaskManager tempManager = new TaskManager();
		tempManager.resetData(taskManager);
		undoTaskManager.push(tempManager);
		System.out.println(undoTaskManager.size());
		clearRedoStack();
	}

	/**
	 * This method clears the redo stack of taskmanagers. This occurs when a new
	 * arraylist is created.
	 */
	private void clearRedoStack() {
		redoTaskManager = new Stack<TaskManager>();
	}

	/**
	 * This method checks if the undo stack size is above the maximum allowed
	 * size
	 */
	private void removeUndoEntriesIfUndoStackSizeTooLarge() {
		if (undoTaskManager.size() >= MAXIMUM_SIZE_OF_UNDO_STACK) {
			removeHalfOfUndoStack(undoTaskManager);
		}
	}

	/**
	 * This method removes half of a stack of TaskManagers given to it. TODO-
	 * test this method
	 */
	private void removeHalfOfUndoStack(Stack<TaskManager> currStack) {
		Stack<TaskManager> tempUndoTaskManager = new Stack<TaskManager>();
		for (int i = 0; i < NEW_SIZE_OF_UNDO_STACK_AFTER_RESIZE; i++) {
			tempUndoTaskManager.push(undoTaskManager.pop());
		}
		while (!undoTaskManager.isEmpty()) {
			undoTaskManager.pop();
		}
		while (!tempUndoTaskManager.isEmpty()) {
			undoTaskManager.push(tempUndoTaskManager.pop());
		}
	}

	@Override
	public synchronized void deleteEvent(ReadOnlyEvent target) throws EventNotFoundException {
		taskManager.removeEvent(target);
		indicateTaskManagerChanged();
	}

```
###### \src\main\java\org\teamstbf\yats\model\ModelManager.java
``` java

	@Override
	public boolean checkEmptyUndoStack() {
		return undoTaskManager.isEmpty();
	}

	@Override
	public boolean checkEmptyRedoStack() {
		return redoTaskManager.isEmpty();
	}

	@Override
	public synchronized void getPreviousState() {
		TaskManager tempManager = new TaskManager();
		tempManager.resetData(taskManager);
		redoTaskManager.push(tempManager);
		taskManager.resetData(undoTaskManager.pop());
		indicateTaskManagerChanged();
	}

	@Override
	public synchronized void getNextState() {
		TaskManager tempManager = new TaskManager();
		tempManager.resetData(taskManager);
		undoTaskManager.push(tempManager);
		taskManager.resetData(redoTaskManager.pop());
		indicateTaskManagerChanged();
	}

	@Override
	public void scheduleEvent(Event event) {
		indicateTaskManagerChanged();
	}

```
###### \src\main\java\org\teamstbf\yats\model\TaskManager.java
``` java

/**
 * Wraps all data at the task manager level Duplicates are not allowed (by
 * .equals comparison)
 */
public class TaskManager implements ReadOnlyTaskManager {

	private final UniqueEventList events;
	private final UniqueTagList tags;

	/*
	 * The 'unusual' code block below is an non-static initialization block,
	 * sometimes used to avoid duplication between constructors. See
	 * https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html
	 *
	 * Note that non-static init blocks are not recommended to use. There are
	 * other ways to avoid duplication among constructors.
	 */
	{
		events = new UniqueEventList();
		tags = new UniqueTagList();
	}

	public TaskManager() {
	}

	/**
	 * Creates an TaskManager using the Persons and Tags in the
	 * {@code toBeCopied}
	 */
	public TaskManager(ReadOnlyTaskManager toBeCopied) {
		this();
		resetData(toBeCopied);
	}

	//// list overwrite operations

	public void setPersons(List<? extends ReadOnlyEvent> tasks) {
		this.events.setEvents(tasks);
	}

	public void setTags(Collection<Tag> tags) throws UniqueTagList.DuplicateTagException {
		this.tags.setTags(tags);
	}

	public void resetData(ReadOnlyTaskManager newData) {
		assert newData != null;

		setPersons(newData.getTaskList());
		try {
			setTags(newData.getTagList());
		} catch (UniqueTagList.DuplicateTagException e) {
			assert false : "AddressBooks should not have duplicate tags";
		}
		syncMasterTagListWith(events);
	}

	//// person-level operations

	/**
	 * Adds a task to the task manager. Also checks the new task's tags and
	 * updates {@link #tags} with any new tags found, and updates the Tag
	 * objects in the task to point to those in {@link #tags}.
	 *
	 * @throws UniqueEventList.DuplicateEventException
	 *             if an equivalent person already exists.
	 */
	public void addEvent(Event p) {
		storeEventTagImage();
		syncMasterTagListWith(p);
		events.add(p);
	}

	private void storeEventTagImage() {
		UniqueEventList tempEvents = new UniqueEventList();
		tempEvents.setEvents(events);
		UniqueTagList tempTags = new UniqueTagList();
		tempTags.setTags(tags);
	}

	/**
	 * Updates the task in the list at position {@code index} with
	 * {@code editedReadOnlyEvent}. {@code TaskManager}'s tag list will be
	 * updated with the tags of {@code editedReadOnlyEvent}.
	 *
	 * @see #syncMasterTagListWith(Task)
	 *
	 * @throws IndexOutOfBoundsException
	 *             if {@code index} < 0 or >= the size of the list.
	 */
	public void updateEvent(int index, ReadOnlyEvent editedReadOnlyEvent) {
		assert editedReadOnlyEvent != null;

		Event editedTask = new Event(editedReadOnlyEvent);
		syncMasterTagListWith(editedTask);
		// TODO: the tags master list will be updated even though the below line
		// fails.
		// This can cause the tags master list to have additional tags that are
		// not tagged to any person
		// in the person list.
		events.updateEvent(index, editedTask);
	}

	/**
	 * Ensures that every tag in this task: - exists in the master list
	 * {@link #tags} - points to a Tag object in the master list
	 */
	private void syncMasterTagListWith(Event p) {
		final UniqueTagList taskTags = p.getTags();
		tags.mergeFrom(taskTags);

		// Create map with values = tag object references in the master list
		// used for checking person tag references
		final Map<Tag, Tag> masterTagObjects = new HashMap<>();
		tags.forEach(tag -> masterTagObjects.put(tag, tag));

		// Rebuild the list of task tags to point to the relevant tags in the
		// master tag list.
		final Set<Tag> correctTagReferences = new HashSet<>();
		taskTags.forEach(tag -> correctTagReferences.add(masterTagObjects.get(tag)));
		p.setTags(new UniqueTagList(correctTagReferences));
	}

	/**
	 * Ensures that every tag in these tasks: - exists in the master list
	 * {@link #tags} - points to a Tag object in the master list
	 *
	 * @see #syncMasterTagListWith(Task)
	 */
	private void syncMasterTagListWith(UniqueEventList tasks) {
		tasks.forEach(this::syncMasterTagListWith);
	}

	public boolean removeEvent(ReadOnlyEvent key) throws UniqueEventList.EventNotFoundException {
		if (events.remove(key)) {
			return true;
		} else {
			throw new UniqueEventList.EventNotFoundException();
		}
	}

	//// tag-level operations

	public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
		tags.add(t);
	}

	//// utility methods

	@Override
	public String toString() {
		return events.asObservableList().size() + " persons, " + tags.asObservableList().size() + " tags";
		// TODO: refine later
	}

	@Override
	public ObservableList<ReadOnlyEvent> getTaskList() {
		return new UnmodifiableObservableList<>(events.asObservableList());
	}

	@Override
	public ObservableList<Tag> getTagList() {
		return new UnmodifiableObservableList<>(tags.asObservableList());
	}

	@Override
	public boolean equals(Object other) {
		return other == this // short circuit if same object
				|| (other instanceof TaskManager // instanceof handles nulls
						&& this.events.equals(((TaskManager) other).events)
						&& this.tags.equalsOrderInsensitive(((TaskManager) other).tags));
	}

	@Override
	public int hashCode() {
		// use this method for custom fields hashing instead of implementing
		// your own
		return Objects.hash(events, tags);
	}

}
```
###### \src\main\java\org\teamstbf\yats\ui\TaskCard.java
``` java

public class TaskCard extends UiPart<Region> {

	@FXML
	private HBox cardPane;
	@FXML
	private Label name;
	@FXML
	private Label id;
	@FXML
	private Label loc;
	@FXML
	private Label description;
	@FXML
	private Label startTime;
	@FXML
	private Label hypen;
	@FXML
	private Label endTime;
	@FXML
	private Label deadline;
	@FXML
	private FlowPane tags;

	public TaskCard(ReadOnlyEvent task, int displayedIndex, String FXML) {
		super(FXML);
		id.setText(displayedIndex + ". ");
		loc.setText(task.getLocation().value);
		description.setText(task.getDescription().value);
		if (task.isRecurring()) {
			// recurring task shows recurrence in its name
			name.setText(task.getTitle().fullName + " [" + task.getRecurrence().getPeriodicity() + "]");
			// recurring task concatenates [time] in Event and [date] inside
			// Recurrence
			if (task.hasStartAndEndTime()) {
				startTime.setText(task.getStartTime().getTimeOnlyString()
						+ task.getRecurrence().getLatestUndoneDateString() + " - ");
				endTime.setText(
						task.getEndTime().getTimeOnlyString() + task.getRecurrence().getLatestUndoneDateString());
			} else {
				startTime.setText("");
				endTime.setText("");
			}
			if (task.hasDeadline()) {
				deadline.setText(" by " + task.getDeadline().getTimeOnlyString()
						+ task.getRecurrence().getLatestUndoneDateString());
			} else {
				deadline.setText("");
			}
		} else {
			// other tasks does not have periodicity
			name.setText(task.getTitle().fullName);
			// other tasks show date and time as usual
			if (task.hasStartOrEndTime()) {
				startTime.setText(task.getStartTime().toString() + " - ");
				endTime.setText(task.getEndTime().toString());
			} else {
				startTime.setText("");
				endTime.setText("");
			}
			if (task.hasDeadline()) {
				deadline.setText(" by " + task.getDeadline().toString());
			} else {
				deadline.setText("");
			}
		}
		initTags(task);
	}

	private void initTags(ReadOnlyEvent person) {
		person.getTags().forEach(tag -> tags.getChildren().add(new Label(tag.tagName)));
	}
}
```
